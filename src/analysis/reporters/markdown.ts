/**
 * Markdown Analysis Reporter
 *
 * Outputs analysis results as formatted Markdown.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { AnalysisReporter } from './base.js';
import {
  AnalysisResult,
  ReporterOptions,
  TestCaseAnalysis,
  EvaluatorAnalysis,
} from '../schemas/analysis.schema.js';

/**
 * Markdown Reporter implementation for analysis results
 */
export class AnalysisMarkdownReporter implements AnalysisReporter {
  readonly name = 'markdown';
  readonly extension = '.md';

  /**
   * Generate Markdown output from analysis result
   *
   * @param analysis - Analysis result to format
   * @param options - Reporter options
   * @returns Markdown string
   */
  async generate(analysis: AnalysisResult, options?: ReporterOptions): Promise<string> {
    const sections: string[] = [];
    const view = options?.view || 'summary';

    // Title and metadata
    sections.push('# youBencha Analysis Report');
    sections.push('');
    sections.push(`**Source:** \`${analysis.metadata.source_file}\`  `);
    sections.push(
      `**Period:** ${analysis.metadata.date_range.earliest.split('T')[0]} ‚Üí ${analysis.metadata.date_range.latest.split('T')[0]}  `
    );
    sections.push(`**Total Runs:** ${analysis.metadata.total_records}  `);
    sections.push(`**Generated:** ${analysis.metadata.generated_at}`);
    sections.push('');
    sections.push('---');
    sections.push('');

    // View-specific content
    switch (view) {
      case 'summary':
        sections.push(this.generateSummarySection(analysis));
        sections.push(this.generateTestCaseSection(analysis.by_test_case, options?.verbose));
        sections.push(this.generateAgentSection(analysis));
        sections.push(this.generateEvaluatorSection(analysis.by_evaluator, options?.verbose));
        sections.push(this.generateInsightsSection(analysis));
        if (options?.verbose) {
          sections.push(this.generateTrendSection(analysis));
        }
        break;
      case 'trends':
        sections.push(this.generateTrendSection(analysis));
        break;
      case 'failures':
        sections.push(this.generateFailuresSection(analysis));
        break;
      case 'assertions':
        sections.push(this.generateAssertionsSection(analysis));
        break;
      case 'comparison':
        sections.push(this.generateComparisonSection(analysis));
        break;
    }

    // Footer
    sections.push('---');
    sections.push('');
    sections.push(`*Report generated by youBencha v${analysis.metadata.youbencha_version}*`);

    return sections.join('\n');
  }

  /**
   * Generate overall summary section
   */
  private generateSummarySection(analysis: AnalysisResult): string {
    const s = analysis.summary;
    const lines: string[] = [];

    lines.push('## Overall Summary');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Total Runs | ${s.total_runs} |`);
    lines.push(`| Passed | ${s.passed_runs} (${(s.pass_rate * 100).toFixed(0)}%) |`);
    lines.push(`| Failed | ${s.failed_runs} (${((s.failed_runs / s.total_runs) * 100).toFixed(0)}%) |`);
    lines.push(`| Partial | ${s.partial_runs} (${((s.partial_runs / s.total_runs) * 100).toFixed(0)}%) |`);
    lines.push(`| Average Duration | ${this.formatDuration(s.avg_duration_ms)} |`);
    lines.push(`| Total Duration | ${this.formatDuration(s.total_duration_ms)} |`);
    lines.push('');

    // Evaluator statistics
    lines.push('### Evaluator Statistics');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Total Evaluations | ${s.evaluator_stats.total_evaluations} |`);
    lines.push(
      `| Passed | ${s.evaluator_stats.passed} (${(s.evaluator_stats.pass_rate * 100).toFixed(0)}%) |`
    );
    lines.push(
      `| Failed | ${s.evaluator_stats.failed} (${((s.evaluator_stats.failed / s.evaluator_stats.total_evaluations) * 100).toFixed(0)}%) |`
    );
    lines.push(
      `| Skipped | ${s.evaluator_stats.skipped} (${((s.evaluator_stats.skipped / s.evaluator_stats.total_evaluations) * 100).toFixed(0)}%) |`
    );
    lines.push('');
    lines.push('---');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate test case section
   */
  private generateTestCaseSection(
    testCases: TestCaseAnalysis[],
    verbose?: boolean
  ): string {
    const lines: string[] = [];

    lines.push('## Analysis by Test Case');
    lines.push('');

    for (const tc of testCases) {
      lines.push(`### ${tc.name}`);
      lines.push('');
      lines.push('| Metric | Value |');
      lines.push('|--------|-------|');
      lines.push(`| Runs | ${tc.run_count} |`);
      lines.push(`| Pass Rate | ${(tc.overall_pass_rate * 100).toFixed(0)}% ${this.getEmoji(tc.overall_pass_rate)} |`);
      lines.push(`| Avg Duration | ${this.formatDuration(tc.avg_duration_ms)} |`);
      lines.push(`| Trend | ${this.formatTrend(tc.recent_trend)} |`);
      lines.push('');

      if (verbose) {
        // Agent breakdown
        lines.push('**Agents Used:**');
        for (const agent of tc.agents_used) {
          lines.push(
            `- \`${agent.type}\`: ${agent.run_count} runs, ${(agent.pass_rate * 100).toFixed(0)}% pass rate`
          );
        }
        lines.push('');

        // Evaluator breakdown
        if (tc.evaluators.length > 0) {
          lines.push('**Evaluators:**');
          lines.push('| Evaluator | Pass Rate | Avg Duration |');
          lines.push('|-----------|-----------|--------------|');
          for (const ev of tc.evaluators) {
            lines.push(
              `| ${ev.name} | ${(ev.pass_rate * 100).toFixed(0)}% | ${this.formatDuration(ev.avg_duration_ms)} |`
            );
          }
          lines.push('');
        }
      }

      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate agent section
   */
  private generateAgentSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Analysis by Agent');
    lines.push('');

    for (const agent of analysis.by_agent) {
      lines.push(`### ${agent.type}`);
      lines.push('');
      lines.push('| Metric | Value |');
      lines.push('|--------|-------|');
      lines.push(`| Total Runs | ${agent.run_count} |`);
      lines.push(`| Execution Success Rate | ${(agent.success_rate * 100).toFixed(0)}% |`);
      lines.push(`| Timeouts | ${agent.timeout_count} |`);
      lines.push(`| Avg Duration | ${this.formatDuration(agent.avg_duration_ms)} |`);
      lines.push('');

      // Performance by test case
      lines.push('**Performance by Test Case:**');
      lines.push('| Test Case | Runs | Pass Rate |');
      lines.push('|-----------|------|-----------|');
      for (const tc of agent.test_cases.slice(0, 10)) {
        lines.push(`| ${tc.name} | ${tc.run_count} | ${(tc.pass_rate * 100).toFixed(0)}% |`);
      }
      lines.push('');
      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate evaluator section
   */
  private generateEvaluatorSection(
    evaluators: EvaluatorAnalysis[],
    verbose?: boolean
  ): string {
    const lines: string[] = [];

    lines.push('## Analysis by Evaluator');
    lines.push('');

    for (const ev of evaluators) {
      lines.push(`### ${ev.name}`);
      lines.push('');
      lines.push('| Metric | Value |');
      lines.push('|--------|-------|');
      lines.push(`| Runs | ${ev.run_count} |`);
      lines.push(`| Pass Rate | ${(ev.pass_rate * 100).toFixed(0)}% ${this.getEmoji(ev.pass_rate)} |`);
      lines.push(`| Skip Rate | ${(ev.skip_rate * 100).toFixed(0)}% |`);
      lines.push(`| Avg Duration | ${this.formatDuration(ev.avg_duration_ms)} |`);
      lines.push('');

      // Assertions if available
      if (ev.assertions && ev.assertions.length > 0 && verbose) {
        lines.push('**Assertions:**');
        lines.push('| Assertion | Evaluations | Pass Rate | Avg Score |');
        lines.push('|-----------|-------------|-----------|-----------|');
        for (const assertion of ev.assertions) {
          lines.push(
            `| ${assertion.assertion_name} | ${assertion.total_evaluations} | ${(assertion.pass_rate * 100).toFixed(0)}% | ${assertion.avg_score.toFixed(2)} |`
          );
        }
        lines.push('');
      }

      // Failure patterns
      if (ev.failure_patterns.length > 0) {
        lines.push('**Common Failures:**');
        for (const pattern of ev.failure_patterns.slice(0, 3)) {
          lines.push(`1. ${pattern.pattern} (${pattern.count} occurrences)`);
        }
        lines.push('');
      }

      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate insights section
   */
  private generateInsightsSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Insights & Recommendations');
    lines.push('');

    if (analysis.insights.length === 0) {
      lines.push('No notable insights at this time.');
      lines.push('');
      return lines.join('\n');
    }

    for (const insight of analysis.insights) {
      const icon = this.getInsightIcon(insight.severity, insight.type);
      lines.push(`### ${icon} ${insight.title}`);
      lines.push('');
      lines.push(insight.description);
      lines.push('');

      if (insight.context.test_case) {
        lines.push(`**Test Case:** ${insight.context.test_case}`);
      }
      if (insight.context.evaluator) {
        lines.push(`**Evaluator:** ${insight.context.evaluator}`);
      }
      lines.push('');
      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate trend section
   */
  private generateTrendSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Trend Analysis');
    lines.push('');
    lines.push('### Pass Rate Over Time');
    lines.push('');
    lines.push('```');
    lines.push('Date        ‚îÇ Runs ‚îÇ Pass Rate');
    lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

    for (const daily of analysis.trends.aggregates.daily.slice(-14)) {
      const date = daily.date.padEnd(12);
      const runs = daily.run_count.toString().padStart(4);
      const passRate = `${(daily.pass_rate * 100).toFixed(0)}%`.padStart(5);
      lines.push(`${date}‚îÇ${runs}  ‚îÇ${passRate}`);
    }
    lines.push('```');
    lines.push('');

    // Trend summary
    const dailies = analysis.trends.aggregates.daily;
    if (dailies.length >= 2) {
      const firstHalf = dailies.slice(0, Math.floor(dailies.length / 2));
      const secondHalf = dailies.slice(Math.floor(dailies.length / 2));

      const firstAvg =
        firstHalf.reduce((sum, d) => sum + d.pass_rate, 0) / firstHalf.length;
      const secondAvg =
        secondHalf.reduce((sum, d) => sum + d.pass_rate, 0) / secondHalf.length;

      const delta = secondAvg - firstAvg;
      if (delta > 0.1) {
        lines.push(
          `üìà **Trend:** Pass rate improving from ${(firstAvg * 100).toFixed(0)}% to ${(secondAvg * 100).toFixed(0)}%.`
        );
      } else if (delta < -0.1) {
        lines.push(
          `üìâ **Trend:** Pass rate declining from ${(firstAvg * 100).toFixed(0)}% to ${(secondAvg * 100).toFixed(0)}%.`
        );
      } else {
        lines.push(`‚û°Ô∏è **Trend:** Pass rate stable at around ${(secondAvg * 100).toFixed(0)}%.`);
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate failures section
   */
  private generateFailuresSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Failure Analysis');
    lines.push('');

    // Test cases with low pass rates
    const failingTcs = analysis.by_test_case.filter((tc) => tc.overall_pass_rate < 0.5);

    if (failingTcs.length === 0) {
      lines.push('No significant failures detected.');
      lines.push('');
    } else {
      lines.push('### Test Cases Needing Attention');
      lines.push('');
      for (const tc of failingTcs) {
        lines.push(
          `- **${tc.name}**: ${(tc.overall_pass_rate * 100).toFixed(0)}% pass rate (${tc.run_count} runs)`
        );
      }
      lines.push('');
    }

    // Common failure patterns
    const allPatterns = analysis.by_evaluator.flatMap((e) =>
      e.failure_patterns.map((p) => ({ ...p, evaluator: e.name }))
    );

    if (allPatterns.length > 0) {
      lines.push('### Common Failure Patterns');
      lines.push('');
      for (const pattern of allPatterns.slice(0, 10)) {
        lines.push(`- **${pattern.evaluator}**: ${pattern.pattern} (${pattern.count}x)`);
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate assertions section
   */
  private generateAssertionsSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Assertion Breakdown');
    lines.push('');

    for (const ev of analysis.by_evaluator) {
      if (ev.assertions && ev.assertions.length > 0) {
        lines.push(`### ${ev.name} Assertions`);
        lines.push('');
        lines.push('| Assertion | Evaluations | Pass Rate | Avg Score |');
        lines.push('|-----------|-------------|-----------|-----------|');

        for (const assertion of ev.assertions) {
          lines.push(
            `| ${assertion.assertion_name} | ${assertion.total_evaluations} | ${(assertion.pass_rate * 100).toFixed(0)}% | ${assertion.avg_score.toFixed(2)} |`
          );
        }
        lines.push('');
      }
    }

    lines.push('---');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate comparison section
   */
  private generateComparisonSection(analysis: AnalysisResult): string {
    const lines: string[] = [];

    lines.push('## Agent Comparison');
    lines.push('');

    // Summary table
    lines.push('| Agent | Runs | Success Rate | Avg Duration |');
    lines.push('|-------|------|--------------|--------------|');
    for (const agent of analysis.by_agent) {
      lines.push(
        `| ${agent.type} | ${agent.run_count} | ${(agent.success_rate * 100).toFixed(0)}% | ${this.formatDuration(agent.avg_duration_ms)} |`
      );
    }
    lines.push('');

    // Detailed comparison per test case
    if (analysis.by_agent.length > 1) {
      lines.push('### Performance by Test Case');
      lines.push('');

      // Get all test cases
      const testCases = new Set<string>();
      for (const agent of analysis.by_agent) {
        for (const tc of agent.test_cases) {
          testCases.add(tc.name);
        }
      }

      // Header
      const header = ['Test Case', ...analysis.by_agent.map((a) => a.type)];
      lines.push('| ' + header.join(' | ') + ' |');
      lines.push('| ' + header.map(() => '---').join(' | ') + ' |');

      for (const tcName of testCases) {
        const row = [tcName.slice(0, 30)];
        for (const agent of analysis.by_agent) {
          const tc = agent.test_cases.find((t) => t.name === tcName);
          if (tc) {
            row.push(`${(tc.pass_rate * 100).toFixed(0)}%`);
          } else {
            row.push('-');
          }
        }
        lines.push('| ' + row.join(' | ') + ' |');
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Format duration in human-readable form
   */
  private formatDuration(ms: number): string {
    if (ms < 1000) return `${ms.toFixed(0)}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
    const minutes = Math.floor(ms / 60000);
    const seconds = ((ms % 60000) / 1000).toFixed(0);
    return `${minutes}m ${seconds}s`;
  }

  /**
   * Format trend
   */
  private formatTrend(trend: string): string {
    switch (trend) {
      case 'improving':
        return '‚Üó Improving';
      case 'stable':
        return '‚Üí Stable';
      case 'degrading':
        return '‚Üò Degrading';
      default:
        return '? Unknown';
    }
  }

  /**
   * Get emoji for pass rate
   */
  private getEmoji(rate: number): string {
    if (rate >= 0.9) return '‚úÖ';
    if (rate >= 0.5) return '‚ö†Ô∏è';
    return '‚ùå';
  }

  /**
   * Get insight icon
   */
  private getInsightIcon(severity: string, type: string): string {
    if (severity === 'critical') return '‚ùå Critical';
    if (severity === 'warning') return '‚ö†Ô∏è Warning';
    if (type === 'improvement') return '‚úÖ Success';
    return '‚ÑπÔ∏è Info';
  }

  /**
   * Write Markdown report to file
   *
   * @param analysis - Analysis result to write
   * @param outputPath - Path where report should be written
   * @param options - Reporter options
   */
  async writeToFile(
    analysis: AnalysisResult,
    outputPath: string,
    options?: ReporterOptions
  ): Promise<void> {
    const content = await this.generate(analysis, options);

    // Ensure parent directory exists
    const dir = path.dirname(outputPath);
    await fs.mkdir(dir, { recursive: true });

    await fs.writeFile(outputPath, content, 'utf-8');
  }
}
